let quizData = [
    // CPU 스케줄링 섹션
    {
        question: "1. CPU 스케줄링 알고리즘을 평가하는 기준과 거리가 먼 것은?",
        options: [
            "CPU 활용률(CPU utilization)",
            "동시성(cocurrency)",
            "준비 큐에서의 대기 시간(waiting time)",
            "자원 활용률(resource efficiency)"
        ],
        answer: 2
    },
    {
        question: "2. CPU 스케줄링의 평가 기준 사이의 관계를 잘못 설명한 것은?",
        options: [
            "CPU 활용률을 높이면 처리율도 높아진다.",
            "공평성을 높이면 CPU 활용률은 상대적으로 떨어진다.",
            "시스템 정책 우선으로 스케줄링하면 CPU 활용률은 높아진다.",
            "응답 시간을 줄이는 알고리즘은 처리율을 높인다."
        ],
        answer: 3
    },
    {
        question: "3. 타임 슬라이스에 대한 설명으로 틀린 것은?",
        options: [
            "스레드에게 할당된 CPU 사용 시간이다.",
            "타이머 인터럽트를 통해 타임 슬라이스가 소진되었는지 검사한다.",
            "타임 슬라이스를 두는 이유는 스레드들에게 공평하게 CPU를 사용하도록 하기 위함이다.",
            "타임 슬라이스가 클수록 컨텍스트 스위칭의 횟수가 증가한다."
        ],
        answer: 4
    },
    {
        question: "4. 다음은 무엇에 대한 설명인가? 스케줄링 과정에서 선택되지 못한 채 오랫동안 준비 리스트에 있는 상황",
        options: [
            "무한대기",
            "교착상태",
            "블록",
            "기아"
        ],
        answer: 4
    },
    {
        question: "5. 다음은 무엇에 대한 설명인가? 스레드가 준비 리스트에 머무르는 시간에 비례하여 우선수위를 높여주는 기법",
        options: [
            "부화 균등화(load balancing)",
            "스레드 마이그레이션(thread migration)",
            "에이징(aging)",
            "우선순위 올림(priority ceiling)"
        ],
        answer: 3
    },
    {
        question: "6. 다음은 무엇에 대한 설명인가? 프로세스나 스레드가 특정 CPU에서 실행되도록 제한하는스케줄러의 특징",
        options: [
            "CPU 친화성 ( CPU affinity )",
            "CPU 마스킹( CPU masking )",
            "하이퍼스레딩",
            "CPU의 부하 균등화"
        ],
        answer: 1
    },
    {
        question: "7. RR(Round Robin) 스케줄링을 사용할 때 오늘날 합리적인 타임 슬라이스로 적합한 것은?",
        options: [
            "5나노초",
            "50마이크로초",
            "50밀리초",
            "500밀리초"
        ],
        answer: 3
    },
    {
        question: "8. 다음은 에이징을 설명하는 문장이다. 빈 칸에 적절한 단어는 무엇인가? 스레드가 준비 리스트에 머무르는 시간에 비례하여 스레드의 (           )을/를 높이는 기법이다.",
        options: [
            "우선순위",
            "nice 값",
            "메모리 할당량",
            "타임 슬라이스"
        ],
        answer: 1
    },
    {
        question: "9. 다음 CPU 스케줄링 알고리즘 중에서 실현성이 없는 것은?",
        options: [
            "FCFS",
            "SJF",
            "MLQ",
            "CFS"
        ],
        answer: 2
    },
    {
        question: "10. 다음 중 모든 스레드에게 CPU를 가장 공평하게 나누어 주는 스케줄링 기법은?",
        options: [
            "RR",
            "FIFO",
            "MLFQ",
            "CLOCK"
        ],
        answer: 1
    },
    {
        question: "11. 다음 중 기아 발생 가능성이 가장 큰 CPU 스케줄링은?",
        options: [
            "FIFO",
            "RR",
            "MLFQ",
            "SJF"
        ],
        answer: 4
    },
    {
        question: "12. 다음 중 기아가 전혀 발생하지 않는 CPU 스케줄링은?",
        options: [
            "RR",
            "SJF",
            "SRTP",
            "MLQ"
        ],
        answer: 1
    },
    {
        question: "13. 어떤 연구소에서 컴퓨터 시스템 사용자들을 책임연구원, 연구원, 연구 보조원의 3 그룹으로 나누어 놓고 각 사용자들이 생성된 프로세스나 스레드의 우선순위를 다르게 매기려고 한다. 가장 적절한 CPU 스케줄링은 무엇인가?",
        options: [
            "RR",
            "SJF",
            "SRTF",
            "MLQ"
        ],
        answer: 4
    },
    {
        question: "14. RR(Round Robin) 스케줄링에서 스레드에게 할당하는 타임 슬라이스의 크기에 관한 설명 중 틀린 것은?",
        options: [
            "타임 슬라이스가 클수록 단번에 완료되는 스레드의 비율이 높아져 FCFS에 가까운 알고리즘이 된다.",
            "타임 슬레이스가 클수록 더 균등한 알고리즘이 된다",
            "타임 슬라이스가 작을수록 처리 시간이 짧은 스레드가 먼저 실행을 종료할 가능성이 높아 SJF에 가까워진다.",
            "타임 슬라이스가 작을수록 스케줄링이 빈번하게 발생하여 시스템 성능 저하가 심해진다"
        ],
        answer: 2
    },
    {
        question: "15. MLFQ(Multi-Level Feedback Queue) 스케줄링에 대한 설명으로 옳은 것은?",
        options: [
            "스레드들이 N개 레벨의 우선순위를 가지고 도착한다.",
            "스레드의 기아를 막기 위해 큐에 대기하는 시간이 오래되면 위 레벨의 큐로 이동시킨다",
            "처음 도착한 스레드는 가장 낮은 우선순위의 큐에 삽입된다.",
            "높은 레벨의 큐일수록 큐 타임 슬라이스가 크다."
        ],
        answer: 2
    },
    {
        question: "16. 단일 코어 CPU와 달리 멀티 코어 CPU에서 스케줄링할 때 특별히 고려할 사항과 거리가 가장 먼 것은?",
        options: [
            "타임 슬라이스",
            "부하 균등화",
            "스레드를 무작위로 코어에게 할당하지 않는다.",
            "코어 친화성"
        ],
        answer: 1
    },
    {
        question: "17. 코어 친화성 혹은 CPU 친화성과 관계가 깊은 것은?",
        options: [
            "캐시",
            "메모리 크기",
            "CPU나 코어 내의 연산장치(ALU)",
            "병령 처리"
        ],
        answer: 1
    },

    // 스레드 동기화 섹션
    {
        question: "18. 여러 스레드가 공유 변수를 접근하려고 경쟁할 때 공유 변수의 값이 훼손되는 상황이 발생할 수 있다. 공유 변수가 훼손되지 않도록 스레드 사이에 공유 변수에 대한 접근 시간과 방법 등을 조절하는 기법을 무엇이라고 하는가.",
        options: [
            "스레드 동기화",
            "멀티스레딩",
            "생산자 소비자 문제",
            "우선순위 역전"
        ],
        answer: 1
    },
    {
        question: "19. 멀티스레드가 동시에 공유 데이터를 접근할 때 데이터가 훼손되지 않도록 막는 기법의 핵심 정책은 무엇인가?",
        options: [
            "상호배제",
            "컨텍스트 스위칭",
            "인터럽트 금지",
            "시스템 호출"
        ],
        answer: 1
    },
    {
        question: "20. 다음은 무엇에 대한 정의인가? 다수의 스레드로부터 공유 데이터의 훼손을 막기 위해 임계구역이 오직 한 스레드만 배타적 독점적으로 사용하도록 관리하는 기술",
        options: [
            "상호배제",
            "멀티스레딩",
            "컨텍스트 스위치",
            "스레드 스케줄링"
        ],
        answer: 1
    },
    {
        question: "21. 원자명령(atomic instruction)이란?",
        options: [
            "CPU 명령",
            "쉘 명령",
            "시스템 호출 명령",
            "C 라이브러리의 특별한 함수"
        ],
        answer: 1
    },
    {
        question: "22. Test and Set Lock 혹은 TSL 명령에 대한 설명이 틀린 것은?",
        options: [
            "CPU 명령",
            "원자명령",
            "상호배제를 위한 명령",
            "스핀락"
        ],
        answer: 4
    },
    {
        question: "23. 다음 원자명령에 대한 설명으로 옳은 것은? TSL ax, lock",
        options: [
            "ax 값을 lock 변수에 기록하고 ax에 0을 저장한다.",
            "ax 값을 lock 변수에 기록하고 ax에 1을 저장한다.",
            "loack 변수 값을 ax에 읽어오고 loack 변수에 0을 저장한다.",
            "lock 변수 값을 ax 에 읽어오고 lock 변수에 1을 저장한다."
        ],
        answer: 4
    },
    {
        question: "24. 원자명령과 가장 거리가 먼 것은?",
        options: [
            "2개의 CPU 명령을 한 번에 처리하기 위해 2개의 CPU 명령을 하나의 CPU 명령으로 만든 것",
            "스핀락과 뮤텍스락 기법도 원자명령을 사용하여 구현한다.",
            "상호배제를 위해 설계된 특별한 CPU 명령",
            "원자명령은 거의 모든 CPU에 있으며 CPU를 막론하고 이름이 동일하다"
        ],
        answer: 4
    },
    {
        question: "25. 임계구역에 대한 설명으로 틀린 것은?",
        options: [
            "임계구역은 짧을수록 좋다.",
            "임계구역은 멀티스레드가 공유 데이터를 엑세스하는 코드 부분이다.",
            "임계구역은 상호배제가 이루어져야 한다.",
            "대부분의 운영체제는 임계구역에 진입할 때 다른 스레드가 진입하지 못하도록 인터럽트를 금지시키고, 나올 때 인터럽트를 허용하는 방법을 사용한다."
        ],
        answer: 4
    },
    {
        question: "26. 멀티스레드의 동기화 기법 중 멀티코어 CPU를 가진 현대의 시스템에 적합한 것은?",
        options: [
            "뮤텍스락",
            "스핀락",
            "세마포",
            "모니터"
        ],
        answer: 2
    },
    {
        question: "27. 멀티스레드의 동기화 기법 중 요청한 자원을 사용할 수 있을 때 까지 대기하는 큐를 사용하지 않는 방법은?",
        options: [
            "뮤텍스락",
            "스핀락",
            "세마포",
            "모니터"
        ],
        answer: 2
    },
    {
        question: "28. 임계구역의 실행 시간이 매우 짧을 경우에 적합한 멀티스레드의 동기화 기법은?",
        options: [
            "뮤텍스락",
            "스핀락",
            "세마포",
            "모니터"
        ],
        answer: 2
    },
    {
        question: "29. 커널 코드나 인터럽트 서비스 루틴 등에서 임계 구역에 접근할 때 멀티스레드 동기화를 위해 사용되는 기법은?",
        options: [
            "뮤텍스락",
            "스핀락",
            "세마포",
            "모니터"
        ],
        answer: 2
    },
    {
        question: "30. 멀티스레드 동기화 기법 중 오랜 시간 동안 공유 자원을 접근하지 못하는 기아가 발생할 수 있는 것은?",
        options: [
            "뮤텍스락",
            "스핀락",
            "세마포",
            "모니터"
        ],
        answer: 2
    },
    {
        question: "31. 멀티스레드의 동기화는 왜 필요한가?",
        options: [
            "여러 스레드가 동시에 실행될 때 스케줄링을 공평하게 유지하기 위해",
            "여러 스레드가 동시에 동일한 변수를 읽고 쓸 때 발생하는 문제를 해결하기 위해",
            "여러 스레드 중 우선순위가 높은 스레드를 우선 스케줄하기 위해",
            "여러 스레드가 실행될 때 병렬성을 높이기 위해"
        ],
        answer: 2
    },
    {
        question: "32. 다음 중 CPU 사용 시간을 심하게 낭비하는 것이 아닌 것은?",
        options: [
            "busy-waiting",
            "sleep-waiting",
            "spinning",
            "busy-looping"
        ],
        answer: 2
    },
    {
        question: "33. 다음 중 동기화가 발생하는 공간에 대한 것 중 옳은 것은?",
        options: [
            "사용자 공간의 코드에서만 동기화 필요요",
            "커널 공간의 코드에서만 동기화 필요",
            "사용자 공간과 커널 공간 모두 동기화 필요",
            "사용자 공간과 커널 공간 모두 동기화 필요 없음"
        ],
        answer: 3
    },
    {
        question: "34. 우선순위 역전에 대한 설명 중 틀린 것은?",
        options: [
            "우선순위 역전이란 늦게 도착한 낮은 순위의 스레드가 높은 순위의 스레드보다 먼저 실행되는 현상이다.",
            "우선순위 역전은 실시간 시스템에서는 허용되어서는 안 되는 중대한 문제이다.",
            "우선순위 올림은 스레드가 공유자원을 소유할 때 미리 정해진 우선순위로 높이는 방법이다.",
            "우선순위 역전은 낮은 순위의 스레드가 기아 상태에 빠지는 것을 막기 위한 매우 효율적인 방법이다."
        ],
        answer: 4
    },
    {
        question: "35. 공유 자원과 가장 거리가 먼 단어는?",
        options: [
            "교착 상태",
            "생산자 소비자 문제",
            "원자명령",
            "N:1 매핑"
        ],
        answer: 4
    },
    {
        question: "36. 생산자 소비자 문제에 대해 잘 설명한 것은?",
        options: [
            "공유 버퍼를 사이에 두고 공유 버퍼에 데이터를 저장하는 스레드와 공유 버퍼로부터 데이터를 읽어가는 스레드 사이에 공유 버퍼에 대한 동시 접근 문제이다.",
            "생산자 소비자 문제는 스레드 동기화 문제라고 볼 수 없다.",
            "생산자보다는 소비자에게 항상 문제가 발생한다.",
            "생산자 소비자 문제는 단일 스레드로 작성되는 응용프로그램에서 주로 발생한다."
        ],
        answer: 1
    },

    // 교착상태 섹션
    {
        question: "37. 식사하는 철학자 문제를 잘못 기술한 것은?",
        options: [
            "식사하는 철학자 문제는 공유 자원에 대한 멀티스레드의 스케줄링 문제이다.",
            "식사하는 철학자 문제는 공유 자원에 대한 멀티스레드와 스레드 동기화 문제이다.",
            "식사하는 철학자 문제는 멀티스레드가 실행되는 컴퓨터 시스템에서 실제 발생할 수 있는 문제이다.",
            "식사하는 철학자 문제에서 포크마다 번호를 매기고 포크가 필요할 때 번호 순으로 포크를 들게 하면 해결된다."
        ],
        answer: 1
    },
    {
        question: "38. 코프만의 4가지 조건에 해당하지 않는 것은?",
        options: [
            "우선순위 역전",
            "자원 강제 반환 불가",
            "소유하면서 대기",
            "환형 대기"
        ],
        answer: 1
    },
    {
        question: "39. 코프만 조건은 어떤 문제에 관한 것인가?",
        options: [
            "교착상태",
            "참조의 지역성",
            "생산자 소비자 문제",
            "PV 연산"
        ],
        answer: 1
    },
    {
        question: "40. 교착상태 무시 전략이 나오게 된 배경이 아닌 것은?",
        options: [
            "교착상태가 그렇게 자주 발생하지 않는다.",
            "교착상태가 발생한다고 피해가 발생하는 것은 아니다.",
            "교착상태에 대한 예방에 너무 많은 자원과 시간이 소모된다.",
            "교착상태에 대한 감지 및 복구 전략에 너무 많은 자원과 시간이 소모된다."
        ],
        answer: 2
    },
    {
        question: "41. 교착상태 예방 전략의 이론적 배경은?",
        options: [
            "코프만 조건",
            "식사하는 철학자 문제",
            "타조 알고리즘",
            "자우너 할당 그래프"
        ],
        answer: 1
    },
    {
        question: "42. 자원할당 그래프를 전혀 사용할 필요가 없는 교착상태 해결 전략은?",
        options: [
            "교착상태 예방",
            "교착상태 회피",
            "교착상태 감지 및 복구",
            "교착상태 무시"
        ],
        answer: 4
    },
    {
        question: "43. 교착상태 관련 알고리즘 중 타조 알고리즘에 대한 설명을 틀린 것은?",
        options: [
            "교착상태에 아무 대비책도 세우지 않는 방법이다.",
            "교착상태가 의심되면 부팅하거나 의심가는 스레드 중 하나를 종료시키는 단순한 방법이다.",
            "타조가 머리를 모래에 박은 것처럼 교착상태가 지나가도록 기다리는 방법이다.",
            "타조 알고리즘으로 교착상태를 해결하면 데이터를 잃어버리는 손실이 발생할 수도 있다."
        ],
        answer: 2
    },
    {
        question: "44. 교착상태 해결 방법중 타조 알고리즘이 적합한 상황은?",
        options: [
            "개인용 PC",
            "환자 감지 시스템",
            "미사일에 탑재되는 컴퓨터 시스템",
            "핵관련 제어 시스템"
        ],
        answer: 1
    },
    {
        question: "45. 교착상태 감지 및 복구와 관련된 방법이 아닌 것은?",
        options: [
            "롤백",
            "모든 자원에 번호를 붙이고 각 스레드는 자원을 할당받을 때 작은 번호의 자원부터 할당받도록 함",
            "교착상태에 빠진 한 스레드의 강제 종료",
            "백그라운드 프로세스를 이용하여 자원할당 그래프를 만들어 교착상태 감지"
        ],
        answer: 2
    },
    {
        question: "46. 교착상태 감지 및 복구 방법에 대한 설명으로 틀린 것은?",
        options: [
            "롤백 방법이 있다.",
            "백그라운드 프로세스를 이용하여 자원할당그래프로부터 교착상태 감지하는 방법이다.",
            "사용자나 시스템 관리자가 교착상태가 발생하였다고 생각되면 시스템을 재시작 시킨다.",
            "이 방법은 너무 많은 시간과 공간을 소모하므로 별로 사용되지 않는다."
        ],
        answer: 3
    },
    {
        question: "47. 교착상태에 대한 설명으로 옳은 것은?",
        options: [
            "교착상태가 발생하면 시스템 전체가 중단된다.",
            "교착상태는 몇 몇 스레드들 사이에서 발생하므로 이들만의 문제이지 시스템 전체의 문제는 아니다.",
            "교착상태는 근본적으로 해결할 수 없기 때문에 교착상태 무시 전략을 사용한다.",
            "교착상태는 응용프로그램들 사이에서 발생하기 보다는 커널 내에서 발생한다."
        ],
        answer: 2
    },
    {
        question: "48. 교착상태는 주로 어디에서 발생하는가?",
        options: [
            "사용자가 작성한 멀티스레드 응용프로그램의 스레드들 사이에",
            "커널 코드 안에서",
            "인터럽트 서비스 루틴 내에서",
            "디바이스 드라이버 코드 안에서"
        ],
        answer: 1
    },

    // 메모리 관리 섹션
    {
        question: "49. 컴퓨터 시스템에서 메모리 계층 구조를 이루는 근본 이유는 무엇인가?",
        options: [
            "CPU의 메모리 액세스 속도를 높이기 위해",
            "컴퓨터 내 저장 용량을 늘리기 위하",
            "가격이 싼 메모리를 사용하여 컴퓨터의 가격을 낮추기 위해",
            "저장 공간을 다양화 하기 위해"
        ],
        answer: 1
    },
    {
        question: "50. 메모리 계층화가 성공적인 이유는?",
        options: [
            "참조의 지역성 때문",
            "CPU 캐시 때문",
            "메모리의 가격 하락 때문",
            "CPU의 속도 증가 때문"
        ],
        answer: 1
    },
    {
        question: "51. 메모리 계층 구조에서 가장 빠른 메모리는?",
        options: [
            "디스크 캐시",
            "메인 메모리 RAM",
            "CPU 내부에 있는 캐시 메모리",
            "CPU 레지스터"
        ],
        answer: 4
    },
    {
        question: "52. 메모리 계층 구조를 구성하는 기억 장치들의 특징으로 틀린 것은?",
        options: [
            "용량이 클수록 속도도 빠르다.",
            "캐시 메모리는 메인 메모리에 비해 거의 10배 이상 속도가 빠르다.",
            "캐시 메모리가 빠를수록 CPU의 처리 능력은 커진다.",
            "캐시 메모리를 많이 사용하지 못하는 것은 비용 문제이다."
        ],
        answer: 1
    },
    {
        question: "53. 운영체제의 메모리 관리 목표에 해당하지 않는 것은?",
        options: [
            "메모리를 연속적으로 할당함으로써 프로세스의 실행 성능 향상",
            "프로세스에게 할당된 메모리를 다른 프로세스로부터 보호",
            "메모리 용량 한계 극복",
            "메모리에 가능한 많은 프로세스를 적재하고 실행하는 메모리 고효율성"
        ],
        answer: 1
    },
    {
        question: "54. 논리 주소에 대해 잘못 설명한 것은?",
        options: [
            "프로세스에 의해 사용되는 주소이다.",
            "모든 프로세스는 각각 0번지에서부터 시작하는 논리 주소를 가진다.",
            "CPU의 PC 레지스터에는 다음에 액세스할 명령의 주소가 들어 있는데 이 주소는 물리 주소이다.",
            "메모리 엑세스 시 논리 주소는 MMU에 의해 물리 주소로 바뀐다."
        ],
        answer: 3
    },
    {
        question: "55. 물리 주소에 대한 설명으로 잘못된 것은?",
        options: [
            "컴파일러가 생성한 주소는 논리 주소이다.",
            "메모리에 대한 하드웨어 주소가 물리주소이며 0번지에서 시작한다.",
            "커널 코드는 물리 주소만 사용한다. 왜냐하면 커널 코드의 빠른 실행을 위해 논리 주소를 물리 주소로 바꾸는 시간을 없애기 위해서이다.",
            "논리 주소를 물리 주소로 바꾸는 장치를 MMU라고 부른다."
        ],
        answer: 3
    },
    {
        question: "56. 다음 프로그램은 C 언어에서 100바이트의 메모리를 동적 할당 받는 코드이다. 포인터 변수 p에는 동적 할당받은 메모리의 주소가 들어 있다. 포인터 변수 p에 들어 있는 주소는 무슨 주소인가? int *p = (int*)malloc(100);",
        options: [
            "논리 주소",
            "물리 주소",
            "옵셋 주소",
            "절대 주소"
        ],
        answer: 1
    },
    {
        question: "57. 다음 중 절대 주소 300번지는?",
        options: [
            "황수연 학생은 자신이 작성한 C 프로그램의 배열 n의 시작 주소가 300번지라는 것을 디버거를 통해 보았다.",
            "CPU 패키지를 통해 출력된 주소 300이 주소 버스를 타고 메모리 장치에 도달하였다.",
            "컴파일러는 변수 n을 300번지에 할당하고, n=10;의 코드를 300번지에 10을 넣도록 컴파일하였다",
            "malloc(10)을 이용하여 동적 할당받은 10바이트의 시작 주소를 출력하니 300번지이다."
        ],
        answer: 2
    },
    {
        question: "58. 비주얼 스튜디오를 이용하여 C 응용프로그램을 작성하고 컴파일하였다. 응용프로그램 내에 선언된 변수 n의 절대주소를 알 수 있는 존재는?",
        options: [
            "프로그램 사용자",
            "비주얼 스튜디오 컴파일러",
            "비주얼 스튜디오 디버거",
            "위의 어떤 것도 알 수 없다"
        ],
        answer: 4
    },
    {
        question: "59. 연속 메모리 할당이 분할 메모리 할당보다 나은 면은?",
        options: [
            "논리 주소와 물리 주소 사이의 매핑 과정이 단순하여 상대적으로 빠른 프로세스의 실행",
            "단편화가 생기지 않음",
            "적은 메모리를 효율적으로 사용",
            "메모리를 연속적으로 할당하여 메모리 낭비 최소화"
        ],
        answer: 1
    },
    {
        question: "60. 분할 메모리 할당은 연속 메모리 할당의 어떤 면을 개선하기 위한 것인가?",
        options: [
            "메모리 할당 시간을 개선하기 위해",
            "여러 개의 물리 메모리(RAM)로 메모리 확장을 용이하게 하기 위해",
            "사용자 공간과 커널 공간의 관리를 쉽게 하기 위해",
            "메모리에 빈 영역이 많이 산재되어 있음에도 불구하고 프로세스를 적재할 수 없는 메모리 할당의 경직성을 극복하기 위해"
        ],
        answer: 4
    },
    {
        question: "61. 세그먼테이션과 페이징에 대해 잘못 설명한 것은?",
        options: [
            "세그먼테이션이나 페이징 모두 세그먼트 테이블과 페이지 테이블이 프로세스마다 1개씩 존재한다.",
            "세그먼트 크기는 가변적이나 페이지 크기는 고정적이다.",
            "세그먼트는 내용에 따라 나누어지며 페이지는 주소에 따라 나누어진다.",
            "논리 주소는 세그먼테이션에서는 (세그먼트번호, 옵셋)으로, 페이징에서는 (페이지번호, 옵셋)으로 구성된다."
        ],
        answer: 1
    },
    {
        question: "62. 홀 선택 알고리즘 중 요청하는 메모리 크기를 수용하는 홀 (비어 있는 메모리 공간) 중 가장 작은 홀을 선택하는 알고리즘은 무엇인가?",
        options: [
            "first-fit",
            "best-fit",
            "worst-fit",
            "small-fit"
        ],
        answer: 2
    },
    {
        question: "63. 홀 선택 알고리즘은 메모리의 홀(비어 있는 메모리 공간) 중에서 선택하여 요청된 메모리를 할당한다. 요청 크기와 홀의 크기가 같지 않는 경우 할당된 홀에 새로운 홀이 생기게 된다. 이 때 가장 큰 홀을 만들게 되는 알고리즘은 무엇인가?",
        options: [
            "first-fit",
            "best-fit",
            "worst-fit",
            "small-fit"
        ],
        answer: 3
    },
    {
        question: "64. 세그먼테이션 메모리 관리 기법에서 세그먼트 테이블의 항목은 어떤 정보로 구성되는가?",
        options: [
            "세그먼트 번호와 세그먼트의 물리 주소",
            "세그먼트의 크기와 세그먼트의 물리 주소",
            "세그먼트 번호, 세그먼트 크기, 세그먼트의 물리 주소",
            "프로세스 번호, 세그먼트 번호, 세그먼트 크기, 세그먼트의 물리 주소"
        ],
        answer: 2
    },
    {
        question: "65. 세그먼테이션 메모리 관리 기법에서 세그먼트 테이블의 항목에는 세그먼트의 크기 정보가 저장된다. 이것은 어떤 목적으로 사용되는가?",
        options: [
            "세그먼트를 크기 별로 관리하기 위해",
            "CPU가 발생하는 논리 주소가 물리 주소로 바꾸기 위해",
            "물리 메모리에 할당된 전체 세그먼트들의 총량을 알기 위해",
            "CPU에 의해 발생된 논리 주소가 세그먼트가 할당된 무리 메모리의 영역을 넘어섰는지 판단하기 위해"
        ],
        answer: 4
    },
    {
        question: "66. 현대의 컴퓨터에서 CPU 패키지 안에 들어 있지 않는 것은?",
        options: [
            "ALU",
            "MMU",
            "CPU 캐시",
            "SSD"
        ],
        answer: 4
    },

    // 페이징 섹션
    {
        question: "67. 프로세스가 실행될 때 변수의 물리주소를 알아내기 위해 사용하는 것은?",
        options: [
            "페이지 테이블",
            "TCB",
            "PCB",
            "프로세스 테이블"
        ],
        answer: 1
    },
    {
        question: "68. 32비트의 주소 체계에서 페이지의 크기가 4KB라면, 한 프로세스 당 페이지 테이블의 크기는 얼마인가?",
        options: [
            "1MB",
            "4MB",
            "32GB",
            "무한대로 커질 수 있다."
        ],
        answer: 2
    },
    {
        question: "69. 페이지 테이블에 들어 있는 항목으로 적당한 것은?",
        options: [
            "페이지의 물리 주소",
            "페이지의 물리 주소와 페이지 크기",
            "페이지의 물리 주소와 페이지 크기, 그리고 페이지의 논리 주소",
            "페이지의 물리 주소와 페이지 크기, 페이지의 논리 주소, 그리고 프로세스 번호"
        ],
        answer: 1
    },
    {
        question: "70. 페이지 테이블에 대한 설명으로 틀린 것은?",
        options: [
            "스레드마다 고유한 페이지 테이블이 사용된다.",
            "프로세스마다 고유한 페이지 테이블이 사용된다.",
            "스레드가 실행되는 동안 프로세스의 페이지 테이블이 참조된다.",
            "페이지 테이블은 프로세스의 사용자 공간과 커널 공간 모두에 대해 적용된다."
        ],
        answer: 1
    },
    {
        question: "71. 논리 주소를 물리 주소로 바꿀 때 사용되지 않는 것은?",
        options: [
            "MMU",
            "페이지 테이블",
            "TLB",
            "PCB"
        ],
        answer: 4
    },
    {
        question: "72. 페이지 테이블에 대한 설명 중 틀린 것은?",
        options: [
            "페이지 테이블은 크기가 커서 일반적으로 메모리에 저장된다.",
            "페이지 테이블이 저장된 메모리 주소는 CPU 레지스터 중 하나에 저장된다.",
            "페이지 테이블은 실제로 많은 항목이 비어 있어, 낭비가 심한 문제가 있다.",
            "페이지 테이블은 시스템 전체에 하나 있으며 커널 공간에 저장된다."
        ],
        answer: 4
    },
    {
        question: "73. 논리 주소를 물리 주소로 바꿀 때 사용되지 않는 것은?",
        options: [
            "Page Table Base Register",
            "PC(Program counter) 레지스터",
            "TLB",
            "페이지 테이블"
        ],
        answer: 2
    },
    {
        question: "74. 페이징 기법과 세그먼테이션 기법을 비교한 것으로 틀린 것은?",
        options: [
            "구현 면에서 페이징이 더 우수하다.",
            "세그먼테이션 기법은 CPU마다 세그먼트를 다루는 방법을 달리하므로 이식성에 단점이 있다.",
            "세그먼테이션은 단편화가 적기 때문에 메모리 활용 면에서 페이징보다 우수하다.",
            "페이징은 시스템의 목적에 따라 페이지 크기를 달리 설정할 수 있어 융통성이 높다."
        ],
        answer: 3
    },
    {
        question: "75. 페이지 테이블은 어디에 존재하는가?",
        options: [
            "메인 메모리",
            "캐시 메모리",
            "하드 디스크",
            "CPU의 특정 레지스터들 속에"
        ],
        answer: 1
    },
    {
        question: "76. 페이징에서 프로세스의 논리 주소는?",
        options: [
            "[페이지 번호]",
            "[페이지 번호, 옵셋]",
            "[프레임 번호, 옵셋]",
            "옵셋"
        ],
        answer: 2
    },
    {
        question: "77. TLB는 어떤 문제점을 해결하기 위한 것인가?",
        options: [
            "페이지의 테이블의 크기",
            "페이지 테이블의 엑세스 속도",
            "물리 메모리의 액세스 횟수",
            "물리 메모리의 크기"
        ],
        answer: 3
    },
    {
        question: "78. TLB는 일반적으로 어디에 존재하는가?",
        options: [
            "CPU 패키지의 MMU 장치 내에",
            "커널 영역의 메모리 내에",
            "CPU 캐시 메모리 내에",
            "CPU 패키지 외부 하드웨어 형태로"
        ],
        answer: 1
    },
    {
        question: "79. TLB의 역할은 무엇인가?",
        options: [
            "논리 주소의 빠른 물리 주소 변환",
            "빠른 페이지 테이블 엑세스",
            "물리 메모리의 빠른 액세스",
            "빠른 CPU 연산"
        ],
        answer: 3
    },
    {
        question: "80. 역 페이지 테이블과 멀티레벨 페이지 테이블 기법은 페이지 테이블의 어떤 문제를 개선하기 위한 것인가",
        options: [
            "페이지 테이블의 액세스 속도 개선",
            "페이지 테이블의 낭비 개선",
            "페이지 테이블의 보호",
            "페이지 테이블의 갱신 시간 개선"
        ],
        answer: 2
    },
    {
        question: "81. 역 페이지 테이블을 사용할 때 역 페이지 테이블의 항목은 어떻게 구성되는가?",
        options: [
            "[프레임 번호]",
            "[페이지 번호, 프레임 번호]",
            "[프로세스 번호, 페이지 번호]",
            "[프로세스 번호, 프레임 번호]"
        ],
        answer: 3
    }
];